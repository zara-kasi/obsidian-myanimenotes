name: Generate Code Map Canvas

on:
  push:
    branches:
      - main
    paths:
      - 'src/**/*.ts'
      - 'src/**/*.tsx'
      - 'main.ts'
  
  pull_request:
    branches:
      - main
  
  schedule:
    - cron: '0 0 * * *'
  
  workflow_dispatch:

jobs:
  generate-canvas:
    runs-on: ubuntu-latest
    
    permissions:
      contents: write
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
      
      - name: Debug - List files
        run: |
          echo "=== Repository Structure ==="
          ls -la
          echo ""
          echo "=== Source Directory ==="
          ls -la src/ || echo "src/ directory not found"
          echo ""
          echo "=== Looking for main.ts ==="
          find . -name "*.ts" -type f | head -20
      
      - name: Create enhanced canvas generator
        run: |
          cat > ts-to-canvas.js << 'EOF'
          #!/usr/bin/env node

          const fs = require('fs');
          const path = require('path');

          const CONFIG = {
            nodeWidth: 300,
            nodeHeight: 140,
            horizontalSpacing: 400,
            verticalSpacing: 200,
            colors: {
              entryPoint: '#991b1b',
              file: '#1e3a8a',
              function: '#15803d',
              class: '#9333ea',
              interface: '#ea580c',
              type: '#0891b2'
            }
          };

          function parseTypeScriptFile(filePath) {
            try {
              const content = fs.readFileSync(filePath, 'utf-8');
              const fileName = path.basename(filePath);
              
              const structure = {
                fileName,
                filePath,
                relativePath: filePath,
                imports: [],
                exports: [],
                functions: [],
                classes: [],
                interfaces: [],
                types: [],
                variables: [],
                functionCalls: new Set(),
                classCalls: new Set()
              };

              // Extract ALL imports including destructured
              const importPatterns = [
                /import\s+{([^}]+)}\s+from\s+['"]([^'"]+)['"]/g,  // import { x } from 'y'
                /import\s+(\w+)\s+from\s+['"]([^'"]+)['"]/g,      // import x from 'y'
                /import\s+\*\s+as\s+(\w+)\s+from\s+['"]([^'"]+)['"]/g, // import * as x from 'y'
                /import\s+['"]([^'"]+)['"]/g,                      // import 'y'
              ];

              importPatterns.forEach(regex => {
                let match;
                while ((match = regex.exec(content)) !== null) {
                  const modulePath = match[match.length - 1];
                  structure.imports.push(modulePath);
                }
              });

              // Also check require statements
              const requireRegex = /require\s*\(\s*['"]([^'"]+)['"]\s*\)/g;
              let match;
              while ((match = requireRegex.exec(content)) !== null) {
                structure.imports.push(match[1]);
              }

              // Extract function declarations (more patterns)
              const functionPatterns = [
                /(?:export\s+)?(?:async\s+)?function\s+(\w+)/g,
                /(?:export\s+)?(?:const|let|var)\s+(\w+)\s*=\s*(?:async\s*)?\([^)]*\)\s*=>/g,
                /(\w+)\s*:\s*\([^)]*\)\s*=>/g,  // object method arrow functions
              ];

              functionPatterns.forEach(regex => {
                let match;
                while ((match = regex.exec(content)) !== null) {
                  if (match[1] && !structure.functions.includes(match[1])) {
                    structure.functions.push(match[1]);
                  }
                }
              });

              // Extract classes with more detail
              const classRegex = /(?:export\s+)?(?:abstract\s+)?class\s+(\w+)(?:\s+extends\s+(\w+))?/g;
              while ((match = classRegex.exec(content)) !== null) {
                structure.classes.push(match[1]);
                if (match[2]) {
                  structure.classCalls.add(match[2]); // Track inheritance
                }
              }

              // Extract interfaces
              const interfaceRegex = /(?:export\s+)?interface\s+(\w+)/g;
              while ((match = interfaceRegex.exec(content)) !== null) {
                structure.interfaces.push(match[1]);
              }

              // Extract type aliases
              const typeRegex = /(?:export\s+)?type\s+(\w+)\s*=/g;
              while ((match = typeRegex.exec(content)) !== null) {
                structure.types.push(match[1]);
              }

              // Extract exported variables/constants
              const varRegex = /(?:export\s+)?(?:const|let|var)\s+(\w+)(?:\s*:\s*\w+)?\s*=/g;
              while ((match = varRegex.exec(content)) !== null) {
                if (!structure.functions.includes(match[1])) {
                  structure.variables.push(match[1]);
                }
              }

              // Detect function calls (this finds usage relationships)
              structure.functions.forEach(func => {
                const callRegex = new RegExp(`\\b${func}\\s*\\(`, 'g');
                if (callRegex.test(content)) {
                  structure.functionCalls.add(func);
                }
              });

              // Detect class instantiations
              structure.classes.forEach(cls => {
                const newRegex = new RegExp(`new\\s+${cls}\\s*\\(`, 'g');
                if (newRegex.test(content)) {
                  structure.classCalls.add(cls);
                }
              });

              // Convert Sets to Arrays
              structure.functionCalls = Array.from(structure.functionCalls);
              structure.classCalls = Array.from(structure.classCalls);

              return structure;
            } catch (error) {
              console.error(`Error parsing ${filePath}:`, error.message);
              return null;
            }
          }

          function resolveImportPath(importPath, fromFile, allFiles) {
            // Skip node_modules and external packages
            if (!importPath.startsWith('.') && !importPath.startsWith('/')) {
              return null;
            }

            const fromDir = path.dirname(fromFile);
            let resolved = path.resolve(fromDir, importPath);

            // Try exact match first
            if (allFiles.has(resolved)) {
              return resolved;
            }

            // Try with extensions
            const extensions = ['.ts', '.tsx', '.js', '.jsx'];
            for (const ext of extensions) {
              const withExt = resolved + ext;
              if (allFiles.has(withExt)) {
                return withExt;
              }
            }

            // Try index files
            const indexPaths = [
              path.join(resolved, 'index.ts'),
              path.join(resolved, 'index.tsx'),
            ];
            
            for (const indexPath of indexPaths) {
              if (allFiles.has(indexPath)) {
                return indexPath;
              }
            }

            return null;
          }

          function findAllTypeScriptFiles(dir, fileSet = new Set()) {
            if (!fs.existsSync(dir)) return fileSet;
            
            const items = fs.readdirSync(dir);

            items.forEach(item => {
              const fullPath = path.join(dir, item);
              const stat = fs.statSync(fullPath);

              if (stat.isDirectory()) {
                if (!['node_modules', '.git', 'dist', 'build', '.github'].includes(item)) {
                  findAllTypeScriptFiles(fullPath, fileSet);
                }
              } else if (item.endsWith('.ts') || item.endsWith('.tsx')) {
                fileSet.add(path.resolve(fullPath));
              }
            });

            return fileSet;
          }

          function analyzeProject(entryPoint, projectRoot) {
            console.log(`Scanning project from: ${projectRoot}`);
            
            // Find ALL TypeScript files in the project
            const allFiles = findAllTypeScriptFiles(projectRoot);
            console.log(`Found ${allFiles.size} total TypeScript files`);

            // Parse all files
            const fileMap = new Map();
            const importGraph = new Map();

            allFiles.forEach(filePath => {
              const fileInfo = parseTypeScriptFile(filePath);
              if (!fileInfo) return;

              fileInfo.relativePath = path.relative(projectRoot, filePath);
              fileMap.set(filePath, fileInfo);

              console.log(`  üìÑ ${fileInfo.relativePath}`);
              console.log(`     Functions: ${fileInfo.functions.length}, Classes: ${fileInfo.classes.length}, Imports: ${fileInfo.imports.length}`);
            });

            // Build import graph
            fileMap.forEach((fileInfo, filePath) => {
              const dependencies = [];
              
              fileInfo.imports.forEach(imp => {
                const resolved = resolveImportPath(imp, filePath, allFiles);
                if (resolved && fileMap.has(resolved)) {
                  dependencies.push(resolved);
                }
              });

              importGraph.set(filePath, dependencies);
            });

            console.log(`\nImport connections: ${Array.from(importGraph.values()).reduce((sum, deps) => sum + deps.length, 0)}`);

            return { fileMap, importGraph };
          }

          function createFileNode(fileInfo, x, y, id, isEntryPoint = false) {
            const parts = [];
            
            if (fileInfo.functions.length > 0) {
              const preview = fileInfo.functions.slice(0, 4).join(', ');
              parts.push(`‚ö° ${preview}${fileInfo.functions.length > 4 ? '...' : ''}`);
            }
            
            if (fileInfo.classes.length > 0) {
              const preview = fileInfo.classes.slice(0, 3).join(', ');
              parts.push(`üèõÔ∏è ${preview}${fileInfo.classes.length > 3 ? '...' : ''}`);
            }

            if (fileInfo.interfaces.length > 0) {
              parts.push(`üìã ${fileInfo.interfaces.length} interfaces`);
            }

            if (fileInfo.types.length > 0) {
              parts.push(`üî∑ ${fileInfo.types.length} types`);
            }

            const emoji = isEntryPoint ? 'üöÄ' : 'üìÑ';
            const label = `${emoji} **${fileInfo.relativePath}**\n\n` + 
                         (parts.length > 0 ? parts.join('\n') : 'Exports: ' + (fileInfo.variables.length || 0));

            return {
              id,
              type: 'text',
              x,
              y,
              width: CONFIG.nodeWidth,
              height: CONFIG.nodeHeight,
              color: isEntryPoint ? CONFIG.colors.entryPoint : CONFIG.colors.file,
              text: label
            };
          }

          function createEdge(fromId, toId, edgeId, label = '') {
            return {
              id: edgeId,
              fromNode: fromId,
              toNode: toId,
              color: '#6b7280',
              label: label
            };
          }

          function generateCanvas(entryPoint, projectRoot) {
            if (!fs.existsSync(entryPoint)) {
              console.error(`Entry point not found: ${entryPoint}`);
              return { nodes: [], edges: [] };
            }

            const { fileMap, importGraph } = analyzeProject(entryPoint, projectRoot);
            
            if (fileMap.size === 0) {
              console.error('No TypeScript files found!');
              return { nodes: [], edges: [] };
            }

            const nodes = [];
            const edges = [];
            let nodeId = 1;
            let edgeId = 1;

            const fileToNodeId = new Map();
            const files = Array.from(fileMap.entries());

            // Create nodes with better layout
            const cols = Math.ceil(Math.sqrt(files.length));
            
            files.forEach(([filePath, fileInfo], index) => {
              const col = index % cols;
              const row = Math.floor(index / cols);
              const x = col * CONFIG.horizontalSpacing;
              const y = row * (CONFIG.verticalSpacing + CONFIG.nodeHeight);

              const isEntry = filePath === entryPoint;
              const id = `node-${nodeId++}`;
              
              fileToNodeId.set(filePath, id);
              nodes.push(createFileNode(fileInfo, x, y, id, isEntry));
            });

            // Create edges from import graph
            let connectionCount = 0;
            importGraph.forEach((dependencies, filePath) => {
              const fromId = fileToNodeId.get(filePath);
              
              dependencies.forEach(depPath => {
                const toId = fileToNodeId.get(depPath);
                if (toId) {
                  edges.push(createEdge(fromId, toId, `edge-${edgeId++}`));
                  connectionCount++;
                }
              });
            });

            console.log(`\n‚úÖ Created ${nodes.length} nodes and ${edges.length} connections`);

            // Metadata node
            const metaNode = {
              id: `node-${nodeId++}`,
              type: 'text',
              x: 0,
              y: -250,
              width: 380,
              height: 160,
              color: '#064e3b',
              text: `# üó∫Ô∏è Code Structure Map\n\n` +
                    `**Entry:** ${path.basename(entryPoint)}\n` +
                    `**Files:** ${fileMap.size}\n` +
                    `**Connections:** ${connectionCount}\n` +
                    `**Functions:** ${Array.from(fileMap.values()).reduce((sum, f) => sum + f.functions.length, 0)}\n` +
                    `**Classes:** ${Array.from(fileMap.values()).reduce((sum, f) => sum + f.classes.length, 0)}\n` +
                    `**Updated:** ${new Date().toISOString().split('T')[0]}`
            };
            nodes.unshift(metaNode);

            return { nodes, edges };
          }

          function main() {
            const args = process.argv.slice(2);
            
            if (args.length < 2) {
              console.log('Usage: node ts-to-canvas.js <entry-point-file> <output-canvas-file>');
              process.exit(1);
            }

            const entryPoint = path.resolve(args[0]);
            const outputFile = path.resolve(args[1]);
            const projectRoot = path.dirname(entryPoint);

            console.log('=== Enhanced Canvas Generator ===');
            console.log(`Entry Point: ${entryPoint}`);
            console.log(`Project Root: ${projectRoot}`);
            console.log(`Output: ${outputFile}\n`);

            const canvas = generateCanvas(entryPoint, projectRoot);
            
            if (canvas.nodes.length === 0) {
              console.error('ERROR: No nodes generated!');
              process.exit(1);
            }

            fs.writeFileSync(outputFile, JSON.stringify(canvas, null, 2));
            console.log(`\n‚úÖ Canvas saved to: ${outputFile}`);
          }

          main();
          EOF
          
          chmod +x ts-to-canvas.js
      
      - name: Find main.ts location
        id: find_main
        run: |
          if [ -f "src/main.ts" ]; then
            echo "main_path=src/main.ts" >> $GITHUB_OUTPUT
            echo "‚úÖ Found main.ts at src/main.ts"
          elif [ -f "main.ts" ]; then
            echo "main_path=main.ts" >> $GITHUB_OUTPUT
            echo "‚úÖ Found main.ts at root"
          else
            echo "‚ùå ERROR: main.ts not found!"
            find . -name "*.ts" -type f | head -10
            exit 1
          fi
      
      - name: Generate Canvas file
        run: |
          echo "Generating enhanced canvas..."
          node ts-to-canvas.js ${{ steps.find_main.outputs.main_path }} ./code-map.canvas
      
      - name: Verify Canvas
        run: |
          if [ ! -f "./code-map.canvas" ]; then
            echo "‚ùå Canvas file not created!"
            exit 1
          fi
          
          echo "‚úÖ Canvas file created"
          echo "Size: $(wc -c < ./code-map.canvas) bytes"
          
          # Check if it has actual content
          node_count=$(grep -o '"type"' ./code-map.canvas | wc -l)
          echo "Nodes found: $node_count"
          
          if [ "$node_count" -lt 2 ]; then
            echo "‚ö†Ô∏è WARNING: Very few nodes detected!"
          fi
      
      - name: Create docs directory
        run: mkdir -p docs
      
      - name: Move Canvas to docs
        run: |
          cp ./code-map.canvas docs/code-map.canvas
          ls -lh docs/
      
      - name: Check for changes
        id: check_changes
        run: |
          git add docs/code-map.canvas
          if git diff --staged --quiet; then
            echo "changed=false" >> $GITHUB_OUTPUT
            echo "‚ÑπÔ∏è No changes detected"
          else
            echo "changed=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Changes detected"
          fi
      
      - name: Commit and push
        if: steps.check_changes.outputs.changed == 'true'
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          git commit -m "üó∫Ô∏è Update code map [skip ci]"
          git push
      
      - name: Upload Canvas artifact
        uses: actions/upload-artifact@v4
        with:
          name: code-map-canvas
          path: docs/code-map.canvas
          retention-days: 90
      
      - name: Summary
        run: |
          echo "## üó∫Ô∏è Code Map Generated! üéâ" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          node_count=$(grep -o '"type"' docs/code-map.canvas | wc -l)
          edge_count=$(grep -o '"fromNode"' docs/code-map.canvas | wc -l)
          echo "- **Nodes:** $node_count" >> $GITHUB_STEP_SUMMARY
          echo "- **Connections:** $edge_count" >> $GITHUB_STEP_SUMMARY
          echo "- **Location:** \`docs/code-map.canvas\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Download from the Artifacts section below ‚¨áÔ∏è" >> $GITHUB_STEP_SUMMARY
